198 寻找宝物

9.4.1算法要求
假设你是游戏中的一个专业寻宝人，计划在沿街的房屋中寻宝。每个房屋都藏有一定的宝物，影响你的寻宝的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两个相邻房子在同一晚上被寻宝者找到，寻宝者报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动报警装置能够找到的最高钱。

eg1:
输入：【1，2，3，1】
输出：5-4-3-2-1-null
解释：寻找1号房屋（金额=1），寻找3号（金额=3）最高1+3=4

例子2:
【2，7，9，3，1】
12
解释：寻找1号12，3号9，5号1，最高2+9+1=12

9.4.2解题思路
上题算的是列表中的最大子序和，这题算的是列表最大间隔元素和。假设列表nums只有一个元素，那么最大间隔和就是maxsum=nums【0】。如果nums有2个元素。那么最大间隔元素和就是maxsum=max（nums）。如果3个元素，最大间隔元素和就是max（nums【0】+nums【2】，nums【1】。有点递归的意思。但是在爬楼梯算过了，递归无法通过测试。可以借鉴爬楼梯的解法，重新创建一个数列，只不过不是fib数列。以nums=【2，7，9，3，1】为例。

nums=【2，7，9，3，1】

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
        	return 0

        size=len(nums)
        if size==1:
        	return nums[0]

        dp=[0]*size
        dp[0]=nums[0]
        dp[1]=max(nums[0],nums[1])

        for i in range(2,size):
        	dp[i]=max(dp[i-2]+nums[i],dp[i-1])
        return dp[size-1]